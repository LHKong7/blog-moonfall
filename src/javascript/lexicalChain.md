## 作用域链与语法环境 Scope and Lexical Environment

**Execution Context(执行上下文) and Scope（范围）**

**上下文**： 变量或函数的执行上下文定义了什么数据可以被访问。在JS中，每个上下文都有一个 `variable object` 变量对象来规定哪些变量和函数存在。当作用域执行完自身范围内的所有代码会被销毁（全局上下文在应用被销毁前并不会销毁）。 每一个函数调用会有自己的上下文，函数的上下文会推到**上下文栈**中，当函数结束执行后，会将对应的上下文信息（variable object）pop 出栈。

**作用域链**：当代码执行时，作用域链条的变量对象会被创建，作用是让每一个变量和函数都可以被访问。

本地创建的变量可以与上级变量进行交换赋值。

上下文类型：
- 全局上下文： 在浏览器的环境中，是 `window` 对象，使用 `var` 定义的变量都能在 window对象中查找到，使用 `let` 和 `const` 定义的内容并不存在于全局上下文。
- 函数上下文：当函数被调用时创建，调用结束销毁
- eval：

**作用域链提升**：


作用域链（scope chain）是将一个个作用域串起来，实现变量查找的路径。作用域是存放变量和函数的地方，全局环境有全局作用域，全局作用域存放了全局变量和全局函数，每个函数也有自己的作用域存放着函数中定义的变量
当在函数内部使用一个变量的时候，V8 便会去作用域中去查找

全局作用域是在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8 退出。 而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。

在全局作用域中，通常包含了：
- this
- window
- document
- Web API
V8在编译过程中，会将顶层定义的变量和声明的函数都添加到全局作用域中。全局作用域创建完成后，V8便进入了执行状态。

因为 JavaScript 是基于词法作用域的，词法作用域就是指，查找作用域的顺序是按照函数定义时的位置来决定的。bar 和 foo 函数的外部代码都是全局代码，所以无论你是在 bar 函数中查找变量，还是在 foo 函数中查找变量，其查找顺序都是按照当前函数作用域–> 全局作用域这个路径来的。
