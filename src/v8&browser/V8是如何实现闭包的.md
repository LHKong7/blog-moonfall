# V8是如何实现闭包的

在编译JavaScript的过程中，V8并不会一次性将所有的JavaScript解析为中间代码：
1. 如果一次性解析和编译所有的JavaScript带阿妹，过多的代码会增加编译时间，严重影响首次执行JavaScript代码的速度。
2. 解析完成的字节码和编译之后的机器代码都会放在内存中，如果一次性解析和编译所有JavaScript代码，那么这些中间代码和机器代码将会一直占用内存

基于以上两点，JS解释器都实现了惰性解析：在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会生成AST和字节码，而仅仅生成顶层代码的AST和字节码。

```js
function foo(a,b) {
    var d = 100
    var f = 10
    return d + f + a + b;
}
var a = 1
var c = 4
foo(1, 5)
```
当V8处理这段函数时，会从上而下解析这段代码，在解析过程中首先会遇到 `foo` 函数，由于这只是一个函数声明，V8只会将该函数转换为函数对象。然后继续往下解析，由于后续的代码都是顶层代码，所以V8会为它们生成抽象语法树，代码解析完成后，会按照顺序自上而下执行代码，当执行到 `foo` 函数调用时，过程是从`foo` 函数对象中取出函数代码，然后和编译顶层代码一样，先编译`foo`函数,编译为抽象语法树和字节码，然后在解释执行。

### 为什么闭包会让V8解析代码的过程会变得复杂？
JavaScript中的闭包有三个基础特性：
1. JavaScript语言允许在函数内部定义新的函数
2. 可以在内部函数中访问副函数定义的变量
3. 因为函数是一等公民，所以函数可以作为返回值

```js
function foo() {
    var d = 20
    return function inner(a, b) {
        const c = a + b + d
        return c
    }
}
const f = foo()
```
在上述代码中，定义了 `foo`函数并返回 `inner`函数，同时在 `inner` 函数中访问了 `foo` 函数中的变量 `d`.
上述代码的执行过程:
- 当调用 foo 函数时，foo 函数会将它的内部函数 inner 返回给全局变量 f；
- 然后 foo 函数执行结束，执行上下文被 V8 销毁
- 虽然 foo 函数的执行上下文被销毁了，但是依然存活的 inner 函数引用了 foo 函数作用域中的变量 d

按照通用的做法，d 已经被 v8 销毁了，但是由于存活的函数 inner 依然引用了 foo 函数中的变量 d，这样就会带来两个问题：
1. 当 foo 执行结束时，变量 d 该不该被销毁？如果不应该被销毁，那么应该采用什么策略？
2. 如果采用了惰性解析，那么当执行到 foo 函数时，V8 只会解析 foo 函数，并不会解析内部的 inner 函数，那么这时候 V8 就不知道 inner 函数中是否引用了 foo 函数的变量 d。

正是由于可以在函数内部声明函数并内部函数可以访问函数的变量，让惰性解析在执行到上述代码中的 `foo` 函数

正常的处理方式应该是 foo 函数的执行上下文虽然被销毁了，但是 inner 函数引用的 foo 函数中的变量却不能被销毁，那么 V8 就需要为这种情况做特殊处理，需要保证即便 foo 函数执行结束，但是 foo 函数中的 d 变量依然保持在内存中，不能随着 foo 函数的执行上下文被销毁掉

V8通过预解析器，来防止销毁 `foo`函数的上下文，哪怕采取了惰性解析

V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个：
1. 是判断当前函数是不是存在一些语法上的错误
2. 除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。（如果有的话，就需要把这个变量copy一份到 堆内存中，同时子函数本身也是一个对象，它会被存在堆内存中，这样即使父函数执行完成，内存被释放以后，子函数在执行的时候，依然可以从堆内存中访问copy过来的变量。）
