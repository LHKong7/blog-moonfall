## V8是如何实现微任务的
JavaScript最初是运行在UI线程中的，JS语言就是基于这套通用的UI线程架构而设计的。基于这套基础UI框架，JavaScript又延伸出了很多新的技术，其中应用最广泛的就是 宏任务 和 微任务。

宏任务：消息队列中的等待被主线程执行的事件，每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。

微任务：微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async 等现代前端经常使用的一些技术。我们从这些依赖技术入手，逐步了解微任务。

**主线程，调用栈，消息队列**：
调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。
```js
function bar() {
}
foo(fun){
  fun()
}
foo(bar)
```
当V8准备执行这段代码时，会先将全局执行上下文压入到调用栈中，然后 V8 便开始在主线程上执行 foo 函数，首先它会创建 foo 函数的执行上下文，并将其压入栈中，然后，foo 函数又调用了 bar 函数，那么当 V8 执行 bar 函数时，同样要创建 bar 函数的执行上下文，并将其压入栈中，等 bar 函数执行结束，V8 就会从栈中弹出 bar 函数的执行上下文，最后，foo 函数执行结束，V8 会将 foo 函数的执行上下文从栈中弹出

我们可以使用 setTimeout 来解决栈溢出的问题，setTimeout 的本质是将同步函数调用改成异步函数调用，这里的异步调用是将 foo 封装成事件，并将其添加进消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个任务。

主线程会从消息队列中取出需要执行的宏任务，假设当前取出的任务就是要执行的这段代码，这时候主线程便会进入代码的执行状态。接下来 V8 就要执行 foo 函数了，同样执行 foo 函数时，会创建 foo 函数的执行上下文，并将其压入栈中，当 V8 执行执行 foo 函数中的 setTimeout 时，setTimeout 会将 foo 函数封装成一个新的宏任务，并将其添加到消息队列中，等 foo 函数执行结束，V8 就会结束当前的宏任务，调用栈也会被清空


