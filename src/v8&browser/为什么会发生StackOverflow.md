# 为什么会发生 stack overflow

先说结论： 在V8中，一个JS函数执行时会生成一个栈帧用来记录该函数返回的地址和函数中的局部变量，栈这种数据结构通常是有限的，而当一个函数不断的进行入栈的操作，则会导致栈中的数据过多超出预期的限制，从而发生栈溢出。

```js
function foo() {
 foo() // 是否存在堆栈溢出错误?
}
foo()
```
上述代码会发生栈溢出的问题

#### 栈如何管理函数调用：
函数的特点：
1. 可以被调用，根据嵌套函数中被执行/调用的关系，可以发现函数的调用符合后进先出的策略。
2. 具有作用域机制： 指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们也称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁。

当出现嵌套函数时，例如：
```js
int add(num1,num2) { 
    int x = num1;
    int y = num2;
    int ret = x + y;
    return ret;
}
int main() { 
    int x = 5; 
    int y = 6;
    x = 100; 
    int z = add(x,y);
    return z;
}
```
在函数执行过程中，其内部的临时变量会按照执行顺序被压入到栈中。当上面add函数执行时，会先把参数num1和num2压栈，接着再把变量x，y，ret的值依次压栈，当add函数执行完后，通过`esp` 寄存器找到当前栈顶的位置，然后在栈顶上方添加新元素，新元素添加后，还需要将新元素的地址更新到 `esp` 寄存器中。有了栈顶指针，就很容易恢复 main 函数的执行现场了，当 add 函数执行结束时，只需要将栈顶指针向下移动就可以了。CPU通过 `ebp` 寄存器保存当前函数的起始位置（栈帧指针）用来知道CPU移动到哪个位置。，每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。

在 JavaScript 中，函数的执行过程也是类似的，如果调用一个新函数，那么 V8 会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，而栈结构的容量是固定的，所有如果重复嵌套执行一个函数，那么就会导致栈会栈溢出。

我们现在理解了栈是怎么管理函数调用的了，使用栈有非常多的优势：
1. 栈的结构和非常适合函数调用过程。
2. 在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。

因为栈空间是有限的，这就导致我们在编写程序的时候，经常一不小心就会导致栈溢出，比如函数循环嵌套层次太多，或者在栈上分配的数据过大，都会导致栈溢出，基于栈不方便存放大的数据，因此我们使用了另外一种数据结构用来保存一些大数据，这就是堆。和栈空间不同，存放在堆空间中的数据是不要求连续存放的，从堆上分配内存块没有固定模式的，你可以在任何时候分配和释放它


